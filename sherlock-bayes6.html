<html>
<head><title>Sherlock Bayes, logical detective. A murder mystery game</title></head>
<body>
<div id="sherlockBayes150129" style="height:640px; width:678px; font-family:'Times New Roman'; background-color:Olive; font-size:16px; line-height:17px">
</div>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script type="text/javaScript">
(function () {
/*
features to implement:
resources that limit stuff
random hot tips - cheap cost
great detective insight - higher accuracy
cheaper cost to fill out row/column
cheaper cost for random
difficulty levels
pictures,reactions, tutorial, ui, etc.

on final click, no fuzzing.

things:
next post: no difficulty, but other settings - reactions, resources, score, etc.
from v.5
*/

var DIV_CONTAINER_ID = "sherlockBayes150129";
var POSTBODY=document.getElementById(DIV_CONTAINER_ID);
POSTBODY.style.position="relative"


function chooseRandom(pArray){ // chooses a random element given a probability distribution array
	var rand=Math.random()
	var sum=0
	var i=0
	while (rand>sum) {
		sum+=pArray[i]
		if (i===pArray.length-1){sum+=1}
		i++
	}
	return i-1
}

function makeEvidenceChart(priors,n){
	var evidenceChart=[]
	var culprit=chooseRandom(priors)
	for (var suspect=0;suspect<priors.length;suspect++) {
		var suspectArray=[]
		if (suspect===culprit) {
			for (var i=0;i<n;i++){
				suspectArray.push(true)
			}
		} else {
			var falseCount=0
			for (var i=0;i<n;i++){
				if (Math.random()<P_FALSELY){
					suspectArray.push(true)
				} else {
					suspectArray.push(false)
					falseCount++
				}
			}
			if (falseCount===0) {
				suspectArray[Math.floor(Math.random()*n)]=false
			}
		}
		evidenceChart.push(suspectArray)
	}
	evidenceChart.culprit=culprit
	evidenceChart.query=function(suspect,category,accuracy){
		var suspicion=evidenceChart[suspect][category]
		if (Math.random()<accuracy) {
			return suspicion
		} else {
			return !suspicion
		}
	}
	return evidenceChart
}

function generateDist(){
	var randArray=[]
	var sum=0
	for (var i=0;i<4;i++){
		var rand=Math.random()*0.65+0.35
		randArray.push(rand)
		sum+=rand
	}
	var partialSum=0
	for (var i=0;i<randArray.length-1;i++){
		randArray[i]/=sum
		partialSum+=randArray[i]
	}
	randArray[randArray.length-1]=1-partialSum
	return randArray
}

function makeChartUI(chartIn,categories, width,height,x,y){
	var chartUI=[]
	for (var i=0;i<chartIn.length;i++) {
		var column=[]
		for (var j=0;j<chartIn[0].length;j++) {
			var div=document.createElement("DIV")
			if (i%2===0){
				div.style.backgroundColor="khaki"//rgb(250,250,100)"
			} else{
				div.style.backgroundColor="palegoldenrod"//rgb(250,250,100)"
			}
			div.style.position="absolute"
			div.style.height=height+"px"//54
			div.style.width=width+"px"//99
			div.style.top=j*(parseInt(div.style.height)+1)+y+"px"
			div.style.left=i*(parseInt(div.style.width)+1)+x+"px"

			div.style.textAlign="center"
			div.innerHTML="</br>"+categories[j]
			div.prevQ=[] // new thing. keeps track of previous queries.
			div.suspect=i
			div.category=j
			div.onmouseenter=function(){
				if (!gameState.status.caseOver) {
					var bubbleText
					if (gameState.difficulty===1){
						bubbleText="On the 'Easy' difficulty, investigations are always 100% accurate. We're only using propositional logic, which is just a simplified version of Bayesian logic.<br/>Click on a box to investigate!"
					} else {
						var hintText=["Forensics investigation delivers higher than normal accuracies, but they cost more resources.",
							"Motives Cost a variable amount of resources (for now, change later)", 
							"Looking into the suspect's alibi gives the usual results - normal accuracy, normal costs.", 
							"We can interview character witnesses, but we're likely to get low accuracies. Fortunately, this type of investigation doesn't cost much resources.",
							"Witnesses are highly variable in quality. The results of our investigation may have a very high or a very low accuracy."]
						bubbleText=hintText[this.category]
						if (Math.random()<0.3) {
							bubbleText+="<br/>Click on the box to investigate!"
						}
					}
					speechBubble.update(bubbleText,[])
				}
			}
			div.onmouseleave=function(){}
			div.onclick=function(){
				if (!gameState.status.caseOver) {
					processClick(this.suspect,this.category)
				}
			}
			POSTBODY.appendChild(div)
			column.push(div)
		}
		chartUI.push(column)
	}
	chartUI.reset=function(newChart){
		for (var i=0;i<newChart.length;i++) {
			for (var j=0;j<newChart[0].length;j++) {
				var div=chartUI[i][j]
				div.style.outline=""
				if (i%2===0){
					div.style.backgroundColor="khaki"//rgb(250,250,100)"
				} else{
					div.style.backgroundColor="palegoldenrod"//rgb(250,250,100)"
				}
				div.innerHTML="</br>"+categories[j]
				div.prevQ=[]
			}
		}
	}
	return chartUI
}

function makeSpan(q,i,width,height) {
	var index=[4,6,2,0,8,3,5,7,1]
	var text=document.createElement("SPAN")
	var percent=Math.round(q.accuracy*100)
	text.innerHTML=percent+"%"
	if (q.result) {
		text.style.color="red"
	} else {
		text.style.color="darkgreen"
	}
	text.style.position="absolute"
	//text.style.textShadow="0px 0px 8px #303030"
	//text.style.backgroundColor="yellow"
	if (text.innerHTML.length>3) {text.style.fontSize="12px"} else {text.style.fontSize="14px"}
	//text.style.fontWeight="bold"
	text.style.left=Math.floor(index[i%9]/3)*width+width*0.08+"px"
	text.style.top=index[i%9]%3*height+"px"
	//console.log(i,index,text.style.left,text.style.top,width,height)
	return text
}

function fuzz(thing,difficulty) {
	if (typeof thing[0]==="undefined" && (difficulty===3 || difficulty===4)) { // so it's q
		var newQ={}
		for (var prop in thing) {
			newQ[prop]=thing[prop]
		}
		newQ.accuracy=Math.round(newQ.accuracy*20)/20 //5% precision
		return newQ
	} else if (typeof thing[0]==="number" && difficulty===-1) { // it's pDist. This will never kick in for now because of difficulty =-1
		var newDist=[]
		for (var i=0;i<thing.length;i++) {
			newDist[i]=Math.round((thing[i]+Math.random()*0.099)*10)/10
			if (newDist[i]>1){newDist[i]=1}
			if (newDist[i]<0){newDist[i]=0}
		}
		return newDist
	} else {
		return thing
	}

}
//console.log(fuzz([0.234,0.2355,0.8734,0.56],3))

function processClick(suspect,category){
	var cost=8
	var acccuracy
	switch (category) {
		case 0:
			accuracy=0.83+0.15*2*(Math.random()-0.5)
			cost+=4
			//fingerprints: high accuracy, high cost
			break
		case 1:
			accuracy=0.75+0.15*2*(Math.random()-0.5)
			cost+=Math.round((Math.random()-0.5)*4)
			//motive: variable cost // maybe lower accuracy but higher trigger chance?
			break
		case 2:
			accuracy=0.75+0.15*2*(Math.random()-0.5)
			cost+=0
			//alibi: standard cost and accuracy
			break
		case 3:
			accuracy=0.67+0.15*2*(Math.random()-0.5)
			cost-=4
			//character witnesses: low accuracy, low cost
			break
		case 4:
			accuracy=0.75+0.25*2*(Math.random()-0.5)
			cost+=0
			//eyewitnesses: highly variable accuracy
			break
	}
	if (gameState.difficulty===1) {
		accuracy=1
		cost=8
	}
	var costReductionRate=0.2*Math.sqrt(chartUI[suspect][category].prevQ.length)
	costReductionRate=Math.min(costReductionRate,0.75)
	cost=Math.round(cost*(1-costReductionRate))
	console.log(cost)
	//if (Math.random()<0.5) {accuracy=1}
	//accuracy=1
	//console.log(cost)

	//do math
	var result=chart.query(suspect,category,accuracy)
	var q={result:result, suspect:suspect, category:category, accuracy:accuracy}
	var post=bayesTheorem(q,pDist,chartUI)
	for (var i=0;i<post.length;i++){
		pDist[i]=post[i]
	}
	//console.log("q?", q[1]===undefined, pDist[1]===undefined, typeof asdfaf, typeof q[1]==="undefined", typeof pDist[1])


	///* comment this part out when statistics testing

	//display bars and pDist
	if (gameState.difficulty===3) {
		if (Math.random()<cost*2.5/100) { //mostly conceals
			qMarks.hide()
		} else {
			qMarks.show()
		}
	}
	pBars.update(fuzz(pDist,gameState.difficulty))
	pDistReport.update(fuzz(pDist,gameState.difficulty))
	
	//report query
	var box=chartUI[suspect][category]
	box.innerHTML=""
	//if (box.prevQ.length>9) {box.prevQ.shift()}
	for (var i=box.prevQ.length-1;i>=0;i--){
		if (i===box.prevQ.length-10){break}
		var reportQ=makeSpan(fuzz(box.prevQ[i],gameState.difficulty),i,parseInt(box.style.width)/3,parseInt(box.style.height)/3)
		box.appendChild(reportQ)
		if (i===box.prevQ.length-1) {
			$(reportQ).animate({fontSize:"+=4", left:"-=2"},"fast").animate({fontSize:"-=4",left:"+=2"},"fast")
		}
	}

	//suspects react
	if (Math.random()<0.8) {
		suspectBubble.fadeIn(suspectsText("investigate"),suspect)
	}
	chartUI[suspect][category].onmouseleave=function(){
		suspectBubble.fadeOut()
		chartUI[suspect][category].onmouseleave=function(){}
	}
	portraits.changeExpression(suspect)

	//resources, reporting
	gameState.resources-=cost
	gameStateUI.update(gameState)
	//*/

}

function reveal(chart,chartUI){
	for (var i=0;i<chartUI.length;i++){
		for (var j=0;j<chartUI[0].length;j++){
			if (chart[i][j]) {
				chartUI[i][j].style.backgroundColor="pink"
			} else {
				chartUI[i][j].style.backgroundColor="lightgreen"
			}
			if (i===chart.culprit) {
				chartUI[i][j].style.outline="red solid thin"
			}
		}
	}
}
function conceal(chart,chartUI){
	for (var i=0;i<chartUI.length;i++){
		for (var j=0;j<chartUI[0].length;j++){
			if (i%2===0){
				chartUI[i][j].style.backgroundColor="khaki"
			} else {
				chartUI[i][j].style.backgroundColor="palegoldenrod"
			}
			if (i===chart.culprit) {
				chartUI[i][j].style.outline=""
			}
		}
	}
}

/*//statistics testing
function getMax(array){
	var max=array[0]
	var maxI=0
	for (var i=0;i<array.length;i++){
		if (array[i]>max) {
			max=array[i]
			maxI=i
		}
	}
	return maxI
}
var total=10000
var right=0
var pSum=0
var NUM_CATEGORIES=5
var P_FALSELY=0.5

var pDist=generateDist()
var chart=makeEvidenceChart(pDist,NUM_CATEGORIES)
//var suspectName=["Alice","Bob","Carol","Dan"]
var categoryName=["Forensics", "Motive","Alibi","Character","Witnesses"]
var boxWidth=99
var chartUI=makeChartUI(chart,categoryName,boxWidth,54,275,250)
var priorBoxes=makePriorsBoxes(pDist,boxWidth,275,525)
var pBars=makePBars(pDist,boxWidth,310,137)
var pDistReport=makePDistReport(pDist,boxWidth,305,141)
var portraits=makePortraits(4,boxWidth,295,185)
var sherlockBayesPortrait=makeSherlockBayes(55,240)
var speechBubble=makeDetectiveBubble("Hello. I'm Sherlock Bayes. Are you a logical thinker? Then help me solve a gruesome murder mystery.</br></br>",[],260,225,4,4)
var suspectBubble=makeSuspectBubble("I didn't do it!", 0, boxWidth,370,14,290,160)
var gameState=makeGameState()
var gameStateUI=makeGameStateUI(gameState,12,460)
gameState.difficulty=2

for (var i=0;i<total;i++){
	var j=0
	while (j<30){//pDist[getMax(pDist)]<0.90) {
		var x=Math.floor(Math.random()*4)
		var y=Math.floor(Math.random()*5)
		processClick(x,y,chart,chartUI,pDist)
		j++
	}
	var accuse=getMax(pDist)
	var pVal=pDist[getMax(pDist)]
	if (accuse===chart.culprit){right++}
	pSum+=pVal
	pDist=generateDist()
	chart=makeEvidenceChart(pDist,NUM_CATEGORIES)
	chartUI=makeChartUI(chart,categoryName,boxWidth,54,275,250)

}
console.log("theory:",pSum/total," experiment:",right/total)
//*/

function pFalseSuspicion(suspect,chartUI){ // the probability of having "true" even if innocent, takes previous q into account, takes all-true scenario into account.
	
	//prior probs.
	var pNotN=Math.pow(P_FALSELY,NUM_CATEGORIES) // not normal
	var priorsNotN=[]
	for (var i=0;i<NUM_CATEGORIES;i++) {
		priorsNotN.push((NUM_CATEGORIES-1)/NUM_CATEGORIES)
	}
	var pN=1-pNotN //normal
	var priorsN=[]
	for (var i=0;i<NUM_CATEGORIES;i++) {
		priorsN.push(P_FALSELY)
	}

	function qTrue(q){
		var pQTrue=q.accuracy
		if (!q.result) {pQTrue=1-pQTrue}
		return pQTrue
	}

	function likely(priors, q) { // general
		return priors[q.category]*qTrue(q)+(1-priors[q.category])*(1-qTrue(q))
	}

	function updatePriorsNotN(priorsNotN,q) { //simple tested, works. Sometimes gets array of NaN if guilty
		var probFalse=[]
		for (var i=0;i<NUM_CATEGORIES;i++) {
			probFalse.push(1-priorsNotN[i])
		}
		function likelyNotN(priors,i,q) { // p(~q|priors, i is false hypothesis)
			if (q.category===i){
				return 1-qTrue(q)
			} else {
				return qTrue(q)
			}
		}
		function denomNotN(priors,q) {
			var sum=0
			for (var i=0;i<NUM_CATEGORIES;i++) {
				sum+=priors[i]*likelyNotN(priors,i,q)
			}
			return sum
		}
		var posteriors=[]
		for (var i=0;i<NUM_CATEGORIES;i++) {
			var prob=probFalse[i]*likelyNotN(probFalse,i,q)/denomNotN(probFalse,q)
			if (isNaN(prob)) {prob=1}
			posteriors.push(1-prob)
		}
		return posteriors
	}

	function updatePriorsN(priorsN,q) { //tested, sometimes gives NaN if guilty
		var posteriors=[]
		for (var i=0;i<NUM_CATEGORIES;i++) {
			if (q.category===i) {
				var iTrue=priorsN[i]*qTrue(q)/(priorsN[i]*qTrue(q)+(1-priorsN[i])*(1-qTrue(q)))
			} else {
				var iTrue=priorsN[i]
			}
			posteriors.push(iTrue)
		}
		return posteriors
	}

	function trimPriorsN(priorsN) { //tested, sometimes gives NaN if guilty
		var allTrue=1
		for (var i=0;i<NUM_CATEGORIES;i++) {
			allTrue*=priorsN[i]
		}
		pFinal=[]
		for (var i=0;i<NUM_CATEGORIES;i++) {
			pFinal.push((priorsN[i]-allTrue)/(1-allTrue))
		}
		return pFinal
	}

	function calcLikely_Q(priorsN, priorsNotN, pN, pNotN, q) {
		var pQ_NotN=likely(priorsNotN,q)
		var pQ_N=likely(priorsN,q)

		var output={}
		output.priorsNotN=updatePriorsNotN(priorsNotN,q)
		output.priorsN=updatePriorsN(priorsN,q)
		output.pNotN=pQ_NotN*pNotN/(pQ_NotN*pNotN+pQ_N*pN) //pNotN needs to persist, as part of priors
		output.pN=pQ_N*pN/(pQ_NotN*pNotN+pQ_N*pN) //pN needs to persist, as part of priors

		var likelihood=[]
		for (var i=0;i<NUM_CATEGORIES;i++) {
			likelihood.push(trimPriorsN(output.priorsN)[i]*output.pN+output.priorsNotN[i]*output.pNotN)
		}
		output.likelihood=likelihood //likelihood need not persist.
		return output
	}

	var initialL=[]
	for (var i=0;i<NUM_CATEGORIES;i++) {
		initialL.push(trimPriorsN(priorsN)[i]*pN+priorsNotN[i]*pNotN)
	}
	var stats={priorsNotN:priorsNotN, priorsN:priorsN, pN:pN, pNotN:pNotN, likelihood:initialL}
	for (var i=0;i<NUM_CATEGORIES; i++) {
		var qList=chartUI[suspect][i].prevQ
		for (var j=0; j<qList.length; j++) {
			stats=calcLikely_Q(stats.priorsN, stats.priorsNotN, stats.pN, stats.pNotN, qList[j])
		}
	}
	//console.log("pFalseSuspicion",stats)
	return stats.likelihood
}

/*	
var falseSusp=0 //testing pFalseSuspicion(n,p)
for (var i=0;i<1000;i++){
	var testChart=makeEvidenceChart([1,0,0,0],5)
	if (testChart.query(3,0,1)){
		falseSusp++
		//console.log(testChart,falseSusp)
	}
}
console.log("exp:", falseSusp/1000, "theory: ",pFalseSuspicion({result:true,suspect:1,category:0,accuracy:1},chartUI))
*/

function likelihood(q,numSuspects,unluckyTrueTable) { //P(qResult for qSuspect|suspect)
	var output=[]
	for (var i=0;i<numSuspects;i++) {
		if (i===q.suspect) {
			if (q.result) {output.push(q.accuracy)}
			else {output.push(1-q.accuracy)}	
		} else {
			var likelihood=unluckyTrueTable[q.category]
			likelihood=likelihood*q.accuracy+(1-likelihood)*(1-q.accuracy)
			if (!q.result) {likelihood=1-likelihood}
			output.push(likelihood)
		}
	}
	return output
}

function denominator(priors,likelihoodTable){ //P(result)
	var prob=0
	for (var suspect=0;suspect<priors.length;suspect++){
		prob+=priors[suspect]*likelihoodTable[suspect]
	}
	return prob
}

function bayesTheorem(q,priors,chartUI){
	var posteriors=[]
	var numSuspects=priors.length
	var unluckyTrueTable=pFalseSuspicion(q.suspect,chartUI) // based on prevQ
	var likelihoodTable=likelihood(q,numSuspects,unluckyTrueTable)
	var denom=denominator(priors,likelihoodTable)
	//console.log("suspects",likelihoodTable)
	for (var suspect=0;suspect<priors.length;suspect++){
		var prob
		if (priors[suspect]===1) {
			prob=1
		} else if (priors[suspect]===0) {
			prob=0
		} else {
			prob=priors[suspect]*likelihoodTable[suspect]/denom
		}
		posteriors.push(prob)
	}
	chartUI[q.suspect][q.category].prevQ.push(q)
	return posteriors
}
//q={result:,suspect, category, accuracy}

function makePBars(pDist,width,x,y){ //array of array of divs
	var pBars=[]
	pBars.spacing=width
	for (var i=0;i<pDist.length;i++){
		var div=document.createElement("DIV")
		div.style.backgroundColor="rgb(120,120,250)"
		div.style.position="absolute"
		div.style.height=Math.round(pDist[i]*100)+"px"
		div.style.width=10+"px"
		div.bottomCoord=y // new thing, indicates the bottom of the bar
		div.style.top=div.bottomCoord-parseInt(div.style.height)+"px"
		div.style.left=i*pBars.spacing+x+"px"
		div.style.borderStyle="solid"
		div.style.borderWidth="1px"
		POSTBODY.appendChild(div)
		pBars.push([div])
		//console.log("bottomCoord",div.bottomCoord)
	}
	pBars.reset=function(newDist){
		for (var i=0;i<pBars.length;i++){
			var div=pBars[i][0]
			div.style.height=Math.round(newDist[i]*100)+"px"
			div.style.top=div.bottomCoord-parseInt(div.style.height)+"px"
			for (var j=1;j<pBars[i].length;j++){
				$(pBars[i][j]).remove()
			}
		}
	}
	pBars.update=function(newDist){
		for (var i=0;i<pBars.length;i++){
			var oldBar=$(pBars[i][0]).clone()[0]
			POSTBODY.appendChild(oldBar)
			oldBar.style.backgroundColor="rgba(210,210,250,0.7)"
			pBars[i].splice(1,0,oldBar)
			if (pBars[i].length>15){
				var toDelete=pBars[i].pop()
				$(toDelete).remove()
			}
			///////
			//console.log("to be top:",pBars[i][0].bottomCoord, pBars[i][0],pBars[i][0].style)
			////////
			$(pBars[i][0]).finish()
			$(pBars[i][0]).animate({
				top:pBars[i][0].bottomCoord-Math.round(newDist[i]*100),
				height:Math.round(newDist[i]*100)
			},"slow")
			for (var j=1;j<pBars[i].length;j++){
				//var newWidth=Math.floor(7-j*0.5)
				$(pBars[i][j]).finish()
				$(pBars[i][j]).animate({
					left:"+="+(1+parseInt(pBars[i][j].style.width)),//i*pBars.spacing+20+j*11,
					opacity:"-=0.065",//4/(j+4),
					width:2//Math.max(Math.floor(6-j),1)//"-=1"
				})
			}
		}
	}
	return pBars
}

function makePDistReport(pDist,width,x,y){
	pDistReport=[]
	for (var i=0;i<pDist.length;i++){
		var text=document.createElement("SPAN")
		text.innerHTML=Math.round(pDist[i]*1000)/10+"%"
		text.style.position="absolute"
		text.style.width=width+"px"
		text.style.color="rgba(0,0,0,1)"
		text.style.left=width*i+x+"px"
		text.style.top=y+"px"
		POSTBODY.appendChild(text)
		pDistReport.push([text])
	}
	pDistReport.reset=function(newDist){
		for (var i=0;i<pDist.length;i++){
			var text=pDistReport[i][0]
			text.innerHTML=Math.round(newDist[i]*100)+"%"
			if (pDistReport[i].length===2) {$(pDistReport[i][1]).remove()}
		}
	}
	pDistReport.update=function(pDist){
		for (var i=0;i<pDist.length;i++){
			if (pDistReport[i].length>=2){
				var toDelete=pDistReport[i].pop()
				$(toDelete).remove()
			}
			pDistReport[i].push($(pDistReport[i][0]).clone()[0])
			POSTBODY.appendChild(pDistReport[i][1])
			$(pDistReport[i][1]).finish()
			$(pDistReport[i][1]).animate({
				left:"+=49", 
				opacity:"-=0.3",
				fontSize:"-=7",
				top:"+=1"
			},"fast")//,function(){pDistReport[i][1].innerHTML="<-"+pDistReport[i][1].innerHTML})
			pDistReport[i][0].innerHTML=Math.round(pDist[i]*1000)/10+"%"
			$(pDistReport[i][0]).finish()
			$(pDistReport[i][0]).animate({fontSize:"+=3"},"fast").animate({fontSize:"-=3"},"fast")
		}
	}
	return pDistReport
}

function makeQuestionMarks(n,width,x,y) {
	var questionMarks=[]
	for (var i=0;i<n;i++) {
		var img=document.createElement("IMG")
		POSTBODY.appendChild(img)
		img.style.position="absolute"
		img.style.top=y+"px"
		img.style.left=i*parseInt(width)+x+"px"
		img.style.zIndex=1
		img.src="questionmark.png"
		questionMarks.push(img)
	}
	questionMarks.hide=function(){
		for (var i=0;i<questionMarks.length;i++) {
			questionMarks[i].style.visibility="hidden"
		}
	}
	questionMarks.show=function(){
		for (var i=0;i<questionMarks.length;i++) {
			questionMarks[i].style.visibility="visible"
		}
	}
	questionMarks.alpha=function(alpha){
		for (var i=0;i<questionMarks.length;i++) {
			questionMarks[i].style.opacity=alpha
		}
	}
	return questionMarks
}

function makePortraits(n,width,x,y){
	var portraits=[]
	var sources=["alice.png","bob.png","carol.png","dan.png"]
	var expressions=["happy.png","sad.png","pained.png","flustered.png","surprised.png","angry.png","relieved.png","calm.png","alert.png"]
	var portraitID=["0.png","1.png","2.png","3.png"]
	function setImg(){
		var img=document.createElement("IMG")
		POSTBODY.appendChild(img)
		img.style.position="absolute"
		img.style.top=y+"px"
		img.style.left=i*parseInt(width)+x+"px"
		return img
	}
	for (var i=0;i<n;i++){
		var blankFace=setImg()
		blankFace.src=sources[i]
		var overlay=setImg()
		overlay.src=expressions[Math.floor(Math.random()*expressions.length)]//change later
		var id=setImg()
		id.src=portraitID[i]
		id.onmouseenter=function(){
			if (!gameState.status.caseOver) {
				var suspect=parseInt(this.src.charAt(this.src.length-5))
				portraits.changeExpression(suspect,["alert.png","sad.png","surprised.png","flustered.png"])
				suspectBubble.fadeIn(suspectsText("preAccuse"),suspect)
			}
		}
		id.onmouseleave=function(){
			if (!gameState.status.caseOver) {
				var suspect=parseInt(this.src.charAt(this.src.length-5))
				suspectBubble.fadeOut()
				portraits.changeExpression(suspect)//,["relieved.png","calm.png","angry.png"])
			}
		}
		id.onclick=function(){
			if (!gameState.status.caseOver) {
				accuse(this)
			}
		}
		var face={face:blankFace,expression:overlay,id:id}
		portraits.push(face)
		//console.log(blankFace.style.top,blankFace.style.left)
	}
	portraits.changeExpression=function(suspect,expressionArray){
		if (expressionArray===undefined || expressionArray.length===0){
			var choices=["happy.png","sad.png","pained.png","flustered.png","surprised.png","angry.png","relieved.png","calm.png","alert.png"]
			portraits[suspect].expression.src=choices[Math.floor(Math.random()*expressions.length)]
			//console.log("expression?",face.expression.src,face.face.src)
		} else {
			portraits[suspect].expression.src=expressionArray[Math.floor(Math.random()*expressionArray.length)]
		}
	}
	return portraits
}

function accuse(portrait){
	var suspect=parseInt(portrait.src.charAt(portrait.src.length-5))
	reveal(chart,chartUI)
	qMarks.hide()
	for (var i=0;i<chartUI.length;i++) {
		for (var j=0;j<chartUI[i].length;j++) {
			var box=chartUI[i][j]
			if (box.prevQ.length>0) {box.innerHTML=""}
			for (var k=box.prevQ.length-1;k>=0;k--) {
				if (k===box.prevQ.length-10){break}
				var reportQ=makeSpan(box.prevQ[k],k,parseInt(box.style.width)/3,parseInt(box.style.height)/3)
				box.appendChild(reportQ)
			}
		}
	}
	clearInterval(gameState.status.bleedResources)
	gameState.status.caseOver=true
	suspectBubble.fadeIn(suspectsText("accuse"),suspect)
	portraits.changeExpression(suspect,["pained.png"])
	//console.log(parseInt(portrait.src.charAt(portrait.src.length-5))===chart.culprit,parseInt(portrait.src.charAt(portrait.src.length-5)),chart.culprit)
	var bubbleText
	if (suspect===chart.culprit) {
		bubbleText="YES!!! We caught the murderer! Justice is served! </br></br>Your score will increase by the reward amount. In addition, your remaining resources will be added to your score. Click on the button below to start on a new case."
	} else {
		bubbleText="NOOOOO!!! We falsely accused an innocent person! Woe is us! </br></br>Your score will decrease by the penalty amount. In addition, your remaining resources will be added to your score. Click on the button below to start on a new case."
	}
	speechBubble.update(bubbleText,["New case","reset"])
	gameState.endCase(suspect===chart.culprit) 
	gameStateUI.update(gameState)
}

function makePriorsBoxes(pDist,width,x,y) {
	var boxes=[]
	//console.log(pDist,width,x,y)
	for (var i=0;i<pDist.length;i++){
		var div=document.createElement("DIV")
		div.style.width=width+"px"
		div.style.height=width/2+"px"
		div.style.position="absolute"
		div.style.top=y+"px"
		div.style.left=x+i*(width+1)+"px"
		div.style.textAlign="center"
		div.style.backgroundColor="yellow"
		div.innerHTML="Prior probability:</br>"+Math.round(pDist[i]*100)+"%"
		POSTBODY.appendChild(div)
		boxes.push(div)
	}
	boxes.reset=function(newDist){
		for (var i=0;i<pDist.length;i++){
			boxes[i].innerHTML="Prior probability:</br>"+Math.round(newDist[i]*100)+"%"
		}	
	}
	return boxes
}

function makeDetectiveBubble(text,buttonArray,width,height,x,y){
	var bubbleArrow=document.createElement("IMG")
	bubbleArrow.src="bubbleArrow.png"
	POSTBODY.appendChild(bubbleArrow)
	bubbleArrow.style.position="absolute"
	bubbleArrow.style.top=y+height+"px"
	bubbleArrow.style.left=x+width-80+"px"
	
	var div=document.createElement("DIV")
	div.style.width=width+"px"
	div.style.height=height-20+"px"
	div.style.position="absolute"
	div.style.top=y+"px"
	div.style.left=x+"px"
	div.style.backgroundColor="white"
	div.style.borderRadius=3+"px"
	div.style.padding=3+"px"
	div.innerHTML=text

	var buttonDiv=document.createElement("DIV")
	buttonDiv.style.width=width+"px"
	buttonDiv.style.height=20+"px"
	buttonDiv.style.position="absolute"
	buttonDiv.style.top=y+height-20+"px"
	buttonDiv.style.left=x+"px"
	buttonDiv.style.backgroundColor="white"
	buttonDiv.style.borderRadius=3+"px"
	buttonDiv.style.padding=3+"px"
	//buttonDiv.style.backgroundColor="yellow"
	//buttonDiv.style.border="solid 2px"
	
	for (var i=0;i<buttonArray.length;i++){
		var button=document.createElement("BUTTON")
		//button.style.verticalAlign=-100+"px"
		button.innerHTML=buttonArray[i]
		button.onclick=function(){
			processButton(this.innerHTML)
		}
		buttonDiv.appendChild(button)
		button.style.cssFloat="right"
	}

	POSTBODY.appendChild(div)
	POSTBODY.appendChild(buttonDiv)

	var bubble={text:div,buttons:buttonDiv}
	bubble.update=function(text,buttonArray){
		bubble.text.innerHTML=text
		bubble.buttons.innerHTML=""
		for (var i=0;i<buttonArray.length;i++){
			var button=document.createElement("BUTTON")
			//button.style.verticalAlign=-100+"px"
			button.innerHTML=buttonArray[i]
			button.onclick=function(){
				processButton(this.innerHTML)
			}
			buttonDiv.appendChild(button)
			button.style.cssFloat="right"
		}
	}
	return bubble
}

function makeSuspectBubble(text,i,spacing,width,height,x,y){
	var bubbleArrow=document.createElement("IMG")
	bubbleArrow.src="bubbleArrow.png"
	POSTBODY.appendChild(bubbleArrow)
	bubbleArrow.spacingParameters={xi:x,spacing:spacing}//new thing
	bubbleArrow.style.position="absolute"
	bubbleArrow.height=30//+"px"
	bubbleArrow.style.top=y+height+6+"px"
	bubbleArrow.style.left=x+60+spacing*i+"px"

	//bubbleArrow.style.visibility="hidden"
	var div=document.createElement("DIV")
	div.style.width=width+"px"
	div.style.height=height+"px"
	div.style.position="absolute"
	div.style.top=y+"px"
	div.style.left=x+"px"
	div.style.backgroundColor="white"
	div.style.borderRadius=3+"px"
	div.style.padding=3+"px"
	div.style.textAlign="center"
	div.innerHTML=text
	//div.style.visibility="hidden"
	POSTBODY.appendChild(div)
	var suspectBubble={text:div,arrow:bubbleArrow}
	$(suspectBubble.text).fadeOut(0)//.fadeOut(4000)
	$(suspectBubble.arrow).fadeOut(0)//.fadeOut(4000)
	suspectBubble.fadeIn=function(text,i){
		//console.log("visible:",suspectBubble.text.style.visibility,suspectBubble.arrow.style.visibility)
		suspectBubble.text.innerHTML=text
		var alignment=["left","center","center","right"]
		suspectBubble.text.style.textAlign=alignment[i]
		suspectBubble.arrow.style.left=suspectBubble.arrow.spacingParameters.xi+60+suspectBubble.arrow.spacingParameters.spacing*i+"px"
		//console.log("suspectBubble",text,suspectBubble.text,suspectBubble.arrow)
		$(suspectBubble.text).fadeIn(20)//.fadeOut(4000)
		$(suspectBubble.arrow).fadeIn(20)//.fadeOut(4000)
	}
	suspectBubble.fadeOut=function(){
		//console.log("visible:",suspectBubble.text.style.visibility,suspectBubble.arrow.style.visibility)
		//suspectBubble.text.innerHTML=text
		//console.log("suspectBubble",text,suspectBubble.text,suspectBubble.arrow)
		$(suspectBubble.text).fadeOut(20)//.fadeOut(4000)
		$(suspectBubble.arrow).fadeOut(20)//.fadeOut(4000)
	}
	return suspectBubble
}



function processButton(buttonName){
	if (buttonName==="test" || buttonName==="hard"){
		speechBubble.update("well, apparently this works",["yeah","nowWhat"])
		suspectBubble.fadeIn("new message",1)
	} else if (buttonName==="nowWhat") {
		suspectBubble.fadeOut()
		gameState.newCase()
		gameStateUI.update(gameState)
		//console.log(foo.selector.selectedIndex)
		//foo.selector.selectedIndex="2"
	} else if (buttonName==="reset") {
		reset()
	} else if (buttonName==="New case") {
		//gameState.endCase()
		gameState.status.caseOver=false
		suspectBubble.fadeOut()
		for (var i=0; i<pDist.length; i++){
			portraits.changeExpression(i)
		}
		pDist=generateDist()
		if (gameState.difficulty===1) {pDist=[0.25,0.25,0.25,0.25]}
		if (gameState.difficulty===3) {
			qMarks.show()
		} else if (gameState.difficulty===4) {
			qMarks.show()
			//qMarks.alpha(1)
		}
		else {
			qMarks.hide()
		}
		clearInterval(gameState.status.bleedResources)
		if (gameState.difficulty===4) {
			gameState.status.bleedResources=setInterval(function(){
				gameState.resources--
				gameStateUI.update(gameState)
			},5000)
		}
		chart=makeEvidenceChart(pDist,NUM_CATEGORIES)
		chartUI.reset(chart)
		pBars.reset(pDist)
		pDistReport.reset(pDist)
		priorBoxes.reset(pDist)
		gameState.newCase()
		gameStateUI.update(gameState)

		speechBubble.update("Welcome to a new case, this is a big or a small one, look at the reward/penalties, Start investigating!",[])
	} else if (gameState.difficulty===0 && (buttonName==="circle" || buttonName==="Next")) {
		tutorial()
	} else if (buttonName="Go to Easy Difficulty") {
		gameState.difficulty=1
		reset(1)
	}
	console.log(buttonName)
}

function makeSherlockBayes(x,y){
	var sherlockBayesPortrait=document.createElement("IMG")
	sherlockBayesPortrait.src="sherlockBayes180.png"
	sherlockBayesPortrait.style.position="absolute"
	sherlockBayesPortrait.style.top=y+"px"
	sherlockBayesPortrait.style.left=x+"px"
	POSTBODY.appendChild(sherlockBayesPortrait)
	return sherlockBayesPortrait
}

function makeGameState(){
	var gameState={difficulty:0,resources:100,pGoal:0.8,score:0,reward:100,penalty:-235,caseNumber:1,status:{},
		newCase:function(){
			gameState.caseNumber++
			var pGoal=0.34*Math.random()+0.65
			//pGoal=0.65
			if (gameState.caseNumber===1) {pGoal=0.8}
			gameState.pGoal=pGoal
			var ratio=pGoal/(1-pGoal)
			var standardRatio=80/20
			var beginningRatio=25/75
			gameState.resources=Math.round(100*Math.log(ratio/beginningRatio)/Math.log(standardRatio/beginningRatio))
			gameState.reward=Math.round(gameState.resources)
			var expectation=1.65*(pGoal-0.6)*(1-2.5*(pGoal-0.8))*gameState.reward// ad-hoc formula, but tested and works well.
			gameState.penalty=Math.round((expectation-pGoal*gameState.reward)/(1-pGoal))
			console.log("reward/penalty",gameState,expectation,pGoal,ratio)
		},
		endCase:function(win){
			gameState.score+=gameState.resources
			if (win) {gameState.score+=gameState.reward} else {gameState.score+=gameState.penalty}
		}
	}
	return gameState
}

function makeGameStateUI(gameState,x,y) {
	var selector=document.createElement("SELECT")
	var difficulties=["Difficulty:Tutorial","Difficulty:Easy","Difficulty:Normal","Difficulty:Hard","Difficulty:Very Hard"]
	for (var i=0;i<5;i++){
		var option=new Option(difficulties[i],i)//document.createElement("OPTION")
		//option.text=difficulties[i]
		selector.add(option)
	}
	selector.onchange=function(){
		reset(selector.selectedIndex)
	}
	//selector.selectedIndex=2

	//selector.style.position="absolute"
	//selector.style.top=3

	var text="Case #"+gameState.caseNumber+"</BR>"+"Resources:"+gameState.resources+"</BR>"+
	"Certainty Goal:"+Math.round(gameState.pGoal*100)+"%"+"</BR>"+
	"Reward:"+gameState.reward+"</BR>"+
	"Penalty:"+gameState.penalty+"</BR>"+
	"Score:"+gameState.score
	var textDiv=document.createElement("DIV")
	textDiv.innerHTML=text
	var div=document.createElement("DIV")
	div.style.width=200
	//div.style.height=110
	div.style.position="absolute"
	div.style.top=y+"px"
	div.style.left=x+"px"
	div.style.backgroundColor="white"
	div.style.padding=3+"px"
	div.appendChild(selector)
	div.appendChild(textDiv)
	POSTBODY.appendChild(div)


	gameStateUI={div:div,selector:selector,textDiv:textDiv,
		update:function(gameState){
			gameStateUI.selector.selectedIndex=gameState.difficulty
			var text="Case #"+gameState.caseNumber+"</BR>"+
			"Resources:"+gameState.resources+"</BR>"+
			"Certainty Goal:"+Math.round(gameState.pGoal*100)+"%"+"</BR>"+
			"Reward:"+gameState.reward+"</BR>"+
			"Penalty:"+gameState.penalty+"</BR>"+
			"Score:"+gameState.score
			gameStateUI.textDiv.innerHTML=text
		}
	}
	return gameStateUI
}

function suspectsText(situation, speaker) { // 0-3 for suspects, undefined for any suspect
	var thingsToSay
	if (situation==="preAccuse") {
		thingsToSay=["I'M INNOCENT!", "IT WASN'T ME!","YOU'VE GOT THE WRONG PERSON!","DON'T YOU DARE!", "I DIDN'T DO IT!", "YOU'LL REGRET THIS!", "YOU'RE ACCUSING ME OF MURDER?!", "YOU CAN'T BE SERIOUS!", "THIS IS RIDICULOUS!", "YOU HAVE NO PROOF!"]
	} else if (situation==="accuse") {
		thingsToSay=["NOOOOO!!!"]
	} else if (situation==="investigate") {
		thingsToSay=["You're barking up the wrong tree.", "Why don't you go bother someone else?", "I can explain all this.", "Don't you have real criminals to stop?", "But how can you be sure?", "This is stupid.", "This doesn't prove anything.", "You don't think I'm guilty, do you?", "Psst. I think it was the person next to me.", "Leave me alone!", "You're ruining my life!", "This is so unfair.", "I'm being oppressed!", "I'm gonna sue you!", "Sigh...", "Hmph.", "I'm a good person!", "I could never kill anyone", "I hope you catch whoever did it.", "I'm a nice person. Ask my friends."]
	}
	return thingsToSay[Math.floor(Math.random()*thingsToSay.length)]
}

function reset(difficulty){
	if (difficulty!==undefined) {
		gameState.difficulty=difficulty
	}
	gameState.caseNumber=0 //because New case adds 1.
	gameState.score=0
	clearInterval(gameState.status.bleedResources)
	gameState.status={}
	circle.hide()
	processButton("New case")
	switch (difficulty) {
		case 0:
			tutorial()
			break
		case 1:
			speechBubble.update("On the 'Easy' difficulty, investigations are always 100% accurate. Furthermore, all suspects are equally likely to have committed the crime from the beginning. <br/>Click on a box to investigate!",[])
			break
		case 2:
			speechBubble.update("On the 'Normal' difficulty, investigations generally have less than 100% accuracy. Furthermore, each suspect starts with a different prior probability of having commited the crime. <br/>Click on a box to investigate!",[])
			break
		case 3:
			speechBubble.update("On the 'Hard' difficulty, each suspect's current probability of guilt is concealed. It may randomly appear after an investigation. Furthermore, you don't know the exact accuracy of each investigation, as it's displayed after rounding off to the nearest 5%.<br/>Click on a box to investigate! ",[])
			break
		case 4:
			speechBubble.update("On the 'Very Hard' difficulty, you don't ever get to see the suspect's probabilities until the end of the case. Furthermore, you continuously lose one resource every five seconds.<br/>Click on a box to investigate!",[])
			break
	}
}

function makeCircle(){
	var img=document.createElement("IMG")
	POSTBODY.appendChild(img)
	img.style.position="absolute"
	img.style.zIndex=1
	img.style.visibility="hidden"
	img.src="circle.png"
	img.move=function(x1,y1,x2,y2) {
		var width=x2-x1
		var height=y2-y1
		img.style.left=x1-width/4+"px"
		img.style.top=y1-height/4+"px"
		img.style.width=1.5*width+"px"
		img.style.height=1.5*height+"px"
		img.style.visibility="visible"
		$(img).finish()
		$(img).animate({
			left:x1+"px",
			top:y1+"px",
			width:width+"px",
			height:height+"px"
		},"fast")
	}
	img.hide=function() {
		img.style.visibility="hidden"
	}
	img.onclick=function() {
		processButton("circle")
	}
	return img
}

function tutorial() {
	if (typeof gameState.status.tutorial==="undefined"){ gameState.status.tutorial=0}
	switch (gameState.status.tutorial) {
		case 0:
			chart[0]=[false,true,false,true,false]
			chart[1]=[true,true,true,true,true]
			chart[2]=[false,false,true,false,false]
			chart[3]=[true,false,true,false,true]
			chart.culprit=1
			pDist=[0.35,0.44,0.11,0.10]
			priorBoxes.reset(pDist)
			pBars.reset(pDist)
			pDistReport.reset(pDist)
			//reveal(chart,chartUI) //testing
			gameState.status.caseOver=true
			speechBubble.update("The murderer is one of these four suspects.", ["Next"])
			circle.move(270,170, 670,260)
			circle.onclick=function(){}
			gameState.status.tutorial++
			break		
		case 1:
			speechBubble.update("We will find out who it is by investigating various things about the suspects, by clicking on these boxes.", ["Next"])
			circle.move(265,235, 675,545)
			gameState.status.tutorial++
			break
		case 2:
			speechBubble.update("Let's investigate Alice's motives. Click on the 'Motive' box under Alice.", [])
			circle.move(270,300, 380,365)
			circle.onclick=function(){
				tutorial()
				circle.onclick=function(){}
			}
			gameState.status.tutorial++
			break
		case 3:
			var q={result:true,suspect:0,category:1,accuracy:1}
			var post=bayesTheorem(q,pDist,chartUI)
			for (var i=0;i<post.length;i++){
				pDist[i]=post[i]
			}
			pBars.update(pDist)
			pDistReport.update(pDist)
			var box=chartUI[0][1]
			box.innerHTML=""
			var reportQ=makeSpan(box.prevQ[0],0,parseInt(box.style.width)/3,parseInt(box.style.height)/3)
			box.appendChild(reportQ)
			$(reportQ).animate({fontSize:"+=4", left:"-=2"},"fast").animate({fontSize:"-=4",left:"+=2"},"fast")	
			suspectBubble.fadeIn(suspectsText("investigate"),0)
			circle.onmouseleave=function(){
				suspectBubble.fadeOut()
				circle.onmouseleave=function(){}
			}
			portraits.changeExpression(0)
			gameState.resources-=8
			gameStateUI.update(gameState)

			speechBubble.update("The red 100% means that Alice definitely had a motive for commiting the murder. That doesn't necessarily mean she's the culprit, though.", ["Next"])
			circle.move(270,300, 380,365)
			gameState.status.tutorial++
			break
		case 4:
			speechBubble.update("Let's now investigate the forensic evidence for Alice. Click on the 'Forensics' box under Alice.", [])
			circle.move(270,245, 380,315)
			circle.onclick=function(){
				tutorial()
				circle.onclick=function(){}
			}
			gameState.status.tutorial++
			break

		case 5:
			var q={result:true,suspect:0,category:0,accuracy:0.75}
			var post=bayesTheorem(q,pDist,chartUI)
			for (var i=0;i<post.length;i++){
				pDist[i]=post[i]
			}
			pBars.update(pDist)
			pDistReport.update(pDist)
			var box=chartUI[0][0]
			box.innerHTML=""
			var reportQ=makeSpan(box.prevQ[0],0,parseInt(box.style.width)/3,parseInt(box.style.height)/3)
			box.appendChild(reportQ)
			$(reportQ).animate({fontSize:"+=4", left:"-=2"},"fast").animate({fontSize:"-=4",left:"+=2"},"fast")	
			suspectBubble.fadeIn(suspectsText("investigate"),0)
			circle.onmouseleave=function(){
				suspectBubble.fadeOut()
				circle.onmouseleave=function(){}
			}
			portraits.changeExpression(0)
			gameState.resources-=12
			gameStateUI.update(gameState)

			speechBubble.update("The red 75% means that according to forensics, there is a 75% chance that Alice had contact with the victim around the time of the murder. So there is still a 25% chance that she had NO contact with the victim, in which case she'd be innocent.", ["Next"])
			circle.move(270,245, 380,315)
			gameState.status.tutorial++
			break
		case 6:
			speechBubble.update("The positive result of our previous two investigations has increased Alice's chance of being guilty, but it is not yet certain. Each suspect's chance of being guilty is displayed above that persons' head, and it is updated after each investigation.", ["Next"])
			circle.move(290,40, 360,165)
			gameState.status.tutorial++
			break
		case 7:
			speechBubble.update("Let's next look at the evidence from witnesses concerning Alice. Click on the 'Witnesses' box under Alice.", [])
			circle.move(270,465, 380,530)
			circle.onclick=function(){
				tutorial()
				circle.onclick=function(){}
			}
			gameState.status.tutorial++
			break
		case 8:
			var q={result:false,suspect:0,category:4,accuracy:1}
			var post=bayesTheorem(q,pDist,chartUI)
			for (var i=0;i<post.length;i++){
				pDist[i]=post[i]
			}
			pBars.update(pDist)
			pDistReport.update(pDist)
			var box=chartUI[0][4]
			box.innerHTML=""
			var reportQ=makeSpan(box.prevQ[0],0,parseInt(box.style.width)/3,parseInt(box.style.height)/3)
			box.appendChild(reportQ)
			$(reportQ).animate({fontSize:"+=4", left:"-=2"},"fast").animate({fontSize:"-=4",left:"+=2"},"fast")	
			suspectBubble.fadeIn(suspectsText("investigate"),0)
			circle.onmouseleave=function(){
				suspectBubble.fadeOut()
				circle.onmouseleave=function(){}
			}
			portraits.changeExpression(0)
			gameState.resources-=8
			gameStateUI.update(gameState)

			speechBubble.update("That green 100% means that Alice definitely does NOT match the description of the murderer given by the witnesses. Therefore, she cannot be the culprit. She is innocent.", ["Next"])
			circle.move(270,465, 380,530)
			gameState.status.tutorial++
			break
		case 9:
			speechBubble.update("Notice that her probability of being guilty has now dropped to 0% to reflect her proven innocence.", ["Next"])
			circle.move(290,40, 360,165)
			gameState.status.tutorial++
			break
		case 10:
			speechBubble.update("This probability of being guilty is calculated from all the evidence we gathered in our investigations,", ["Next"])
			circle.move(270,245, 380,525)
			gameState.status.tutorial++
			break
		case 11:
			speechBubble.update("Plus the prior probabilities that we had for the guilt of each suspect. These priors are the degrees to which you think a suspect might be guilty, BEFORE you gather any evidence for the case. It may reflect, for example, their prior criminal records.", ["Next"])
			circle.move(270,515, 675,595)
			gameState.status.tutorial++
			break
		case 12:
			speechBubble.update("Looking at the probabilities, we see that Bob now has the highest chance of being guilty. So let's investigate his alibi. Click on the 'Alibi' box under Bob.", [])
			circle.move(370,355, 480,420)
			circle.onclick=function(){
				tutorial()
				circle.onclick=function(){}
			}
			gameState.status.tutorial++
			break
		case 13:
			var q={result:true,suspect:1,category:2,accuracy:0.9}
			var post=bayesTheorem(q,pDist,chartUI)
			for (var i=0;i<post.length;i++){
				pDist[i]=post[i]
			}
			pBars.update(pDist)
			pDistReport.update(pDist)
			var box=chartUI[1][2]
			box.innerHTML=""
			var reportQ=makeSpan(box.prevQ[0],0,parseInt(box.style.width)/3,parseInt(box.style.height)/3)
			box.appendChild(reportQ)
			$(reportQ).animate({fontSize:"+=4", left:"-=2"},"fast").animate({fontSize:"-=4",left:"+=2"},"fast")	
			suspectBubble.fadeIn(suspectsText("investigate"),0)
			circle.onmouseleave=function(){
				suspectBubble.fadeOut()
				circle.onmouseleave=function(){}
			}
			portraits.changeExpression(1)
			gameState.resources-=8
			gameStateUI.update(gameState)

			speechBubble.update("The red 90% means that Bob offered a very weak alibi. There is a 90% chance that he actually has no alibi. Again, this doesn't necessarily mean that he's guilty, although of course it increases the chance.", ["Next"])
			circle.move(370,355, 480,420)
			gameState.status.tutorial++
			break
		case 14:
			speechBubble.update("What, then, does actual guilt look like? Here we went ahead and 'cheated', by revealing the truth under each of the boxes we're investigating. A red box means that this evidence is compatible with this person being the culprit. A green box means that the evidence is incompatible, so the person must then be innocent.", ["Next"])
			circle.hide()
			reveal(chart,chartUI)
			gameState.status.tutorial++
			break
		case 15:
			speechBubble.update("So, for example, the forensic evidence actually indicates that Alice had NO contact with the victim, although she had the motive to commit the murder and a personal character capable of killing. Furthermore, she has a bulletproof alibi and does not match the descriptions given by the witnesses of the murderer.", ["Next"])
			circle.move(270,145, 380,535)
			gameState.status.tutorial++
			break
		case 16:
			speechBubble.update("Notice that our particular investigation got it wrong on the forensics. It said that there was a 75% chance that Alice had contact with the victim, when in fact she did not. We shouldn't be too surprised, as our investigation still had a 25% chance to be wrong.", ["Next"])
			circle.move(270,245, 380,315)
			gameState.status.tutorial++
			break
		case 17:
			speechBubble.update("Dan, on the other hand, is someone who had contact with the victim, has no alibi, and matches the description given by the witnesses - all of which make him look guilty. But he also has no motive and a personal character incapable of committing a murder. He is therefore actualy innocent.", ["Next"])
			circle.move(570,145, 675,535)
			gameState.status.tutorial++
			break
		case 18:
			speechBubble.update("The true culprit is the one whose entire column is red in every box: Bob. He is compatible with all of the evidence of each type. In each murder case, there will only be one suspect whose entire column of boxes will be red, and that person will be the true culprit. All other suspects will have at least one green box which indicates that they could not be the murderer.", ["Next"])
			circle.move(370,145, 475,535)
			gameState.status.tutorial++
			break
		case 19:
			speechBubble.update("But even the innocent suspects have about a 40% chance for a given box to be red. They were just unlucky in some way - they might have been at the wrong place at the wrong time, like Dan having had contact with the victim despite him being innocent.", ["Next"])
			circle.move(570,245, 675,315)
			gameState.status.tutorial++
			break
		case 20:
			speechBubble.update("Let's hide the answers again and go back to our case: Looking at the probability of guilt, we see that Bob is likely to be guilty based on the priors and the evidence we've gathered. (That, and we just 'cheated' and know that he's the culprit.) So let's accuse him as the murderer. Click on his portrait to make the accusation.", [])
			circle.move(385,170, 460,255)
			conceal(chart,chartUI)
			circle.onclick=function(){
				tutorial()
				circle.onmouseleave=function(){}
				circle.onmouseenter=function(){}
				circle.onclick=function(){}
			}
			circle.onmouseenter=function(){
				portraits.changeExpression(1,["alert.png","sad.png","surprised.png","flustered.png"])
				suspectBubble.fadeIn(suspectsText("preAccuse"),1)
			}
			circle.onmouseleave=function(){
				suspectBubble.fadeOut()
			}
			gameState.status.tutorial++
			break
		case 21:
			speechBubble.update("Our participation in the case is over after we make an accusation. The police take over, the solution is revealed, and we score reward or penalty points depending on whether we got the right person. Our score also changes by how much resources we have remaining. (Resources are used each time you investigate a box.) </br></br>This tutorial case is now closed.", ["Next"])
			circle.move(1,450, 170,615)
			reveal(chart,chartUI)
			suspectBubble.fadeIn(suspectsText("accuse"),1)
			portraits.changeExpression(1,["pained.png"])
			gameState.endCase(true) 
			gameStateUI.update(gameState)
			gameState.status.tutorial++
			break
		case 22:
			speechBubble.update("Good luck on the real cases. Try to score the highest number of points in each case!", ["Go to Easy Difficulty"])
			circle.hide()
			break
}

/*
Our murderer is one of these four suspects. (circle)
We perform the investigation by clicking on these boxes (circle)
Let's investigate Alice's motives. Click on the "Motive" box under Alice. (circle, enable click, 100%)
The red 100% means that Alice definitely had a motive for commiting the murder. That doesn't necessarily mean she's the culprit, though. 
Let's look at the forensic evidence for Alice. Click on the "Forensics" box under Alice.(circle, click, 75%)
The red 75% means that according to forensics, there is a 75% chance that Alice had contact with the victim around the time of the murder. That means there is still a 25% chance that she had NO contact with the victim, in which case she'd be innocent. Also, even if she did really have contact, that doesn't necessarily mean she's guilty.

Let's next look at the witness evidence concerning Alice (circle, click, 100% g)

That green 100% means that Alice definitely does NOT match the description of the murderer given by witnesses. Therefore, she absolutely cannot be the culprit. She is innocent.

Notice that her probability of being guilty, up above her head, has now dropped to 0% to reflect her proven innocent. (circle)

This probability of being guilty is calculated from all the evidence we gathered,

Plus the prior probability that we had for the guilt of each suspect. These are the degrees to which you think a suspect might be guilty, BEFORE you gather any evidence for the case. It may reflect, for example, their prior criminal records. (circle)

Looking at the probabilities, we see that Bob now has the highest chance of being guilty. So let's investigate his Alibi. Click on the "Alibi" box under Bob. (circle, click, 90%)

The red 90% means that Bob offered a very weak alibi. There is a 90% chance that he really has no alibi. Again, this doesn't necessarily mean that he's guilty, although of course this increases the chance.

What, then, does actual guilt look like? Here we went ahead and 'cheated', by revealing the truth under each box we're investigating. A red box means that this evidence is compatible with this person being the culprit, whereas a green box means that the evidence is incompatible with the guilt of this suspect, who must then be innocent. (reveal)

So, for example, the forensic evidence actually indicates that Alice had NO contact with the victim, although she had the motive to commit the murder and a personal character capable of killing. Furthermore, she has a bulletproof alibi and does not match the witness descriptions of the murderer. 

Notice that our particular investigation got it wrong on the forensics: This is not unexpected, as our forensics investigation only had a 75% accuracy and so still had a 25% chance to be wrong. (circle)

Dan, on the other hand, is someone who had contact with the victim, has no alibi, and matches the witness description of the murderer, but he has no motive and a personal character incapable of committing a murder. He is therefore innocent. (circle)

The true culprit is the one whose entire column is red in every box: Bob. He is compatible with all of the evidence. In each murder case, there will only be one suspect whose entire column of boxes will be red, and that person will be the true culprit; all other suspects will have at least one green box which indicates that they could not be the murderer. (circle)

But even these innocent suspects have about a 40% chance for a given box to be red. They were just unlucky in some way - they might have been at the wrong place at the wrong time, like Dan having had contact with the victim despite him being innocent. (circle)

Let's hide the answers again and go back to our case: Looking at the probability of guilt, we see that Bob is very likely to be guilty based on the priors and the evidence we've gathered. (That, and we just 'cheated' and know that he's the culprit.) So let's accuse him as the murderer. Click on his portrait to make the accusation. (circle, click)

That ends our tutorial murder case. After each case, you get points based on whether you accused the right person, and how much resources you have remaining. (Resources are used each time you investigate a box.) (Circle)

Try to increase your score from case to case! (increase difficulty)



*/
}
//function detectiveText(situation, suspect, category){
//}


////functions end, variables begin

var NUM_CATEGORIES=5
var P_FALSELY=0.4

var pDist=generateDist()
var chart=makeEvidenceChart(pDist,NUM_CATEGORIES)
//var suspectName=["Alice","Bob","Carol","Dan"]
var categoryName=["Forensics", "Motive","Alibi","Character","Witnesses"]
var boxWidth=99
var chartUI=makeChartUI(chart,categoryName,boxWidth,54,275,250)
var priorBoxes=makePriorsBoxes(pDist,boxWidth,275,525)
var pBars=makePBars(pDist,boxWidth,310,137)
var pDistReport=makePDistReport(pDist,boxWidth,305,141)
var qMarks=makeQuestionMarks(4,boxWidth,280,20)
qMarks.hide()
var portraits=makePortraits(4,boxWidth,295,185)
var sherlockBayesPortrait=makeSherlockBayes(55,240)
var speechBubble=makeDetectiveBubble("Hello. I'm Sherlock Bayes. Are you a logical thinker? Then help me solve this murder mystery.</br></br>",["Next"],260,225,4,4)
var suspectBubble=makeSuspectBubble("I didn't do it!", 0, boxWidth,370,14,290,160)

var gameState=makeGameState()
gameState.status.caseOver=true
var gameStateUI=makeGameStateUI(gameState,12,460)
//foo.selector.selectedIndex="2"
var circle=makeCircle()




}());

</script>

</body>
</html>